<!DOCTYPE html>
<!-- saved from url=(0047)http://javascript.ruanyifeng.com/oop/basic.html -->
<html class="no-js" lang="en"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">

  <!-- Set the viewport width to device width for mobile -->
  <meta name="viewport" content="width=device-width">

  <title>面向对象编程概述 -- JavaScript 标准参考教程（alpha）</title>
  
  <!-- Included CSS Files (Uncompressed) -->
  <!--
  <link rel="stylesheet" href="stylesheets/foundation.css">
  -->
  
  <!-- Included CSS Files (Compressed) -->
  <link rel="stylesheet" href="http://javascript.ruanyifeng.com/css/foundation.css">
  <link rel="stylesheet" href="http://javascript.ruanyifeng.com/css/main.css">

  <!-- IE Fix for HTML5 Tags -->
  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <script async="" src="./basic_files/analytics.js"></script><script src="./basic_files/jquery.js"></script>
  <script src="./basic_files/toc.js"></script>
  <script src="./basic_files/main.js"></script>

<script type="text/javascript" async="" src="./basic_files/embed.js"></script></head>
<body>

<header class="top-bar" id="header">

<div class="fixed">

<nav class="top-bar">
<ul>
<!-- Title Area -->
	<li class="name has-dropdown">
	<h1><a href="http://javascript.ruanyifeng.com/">JavaScript 标准参考教程（alpha） </a></h1>
		<ul class="dropdown">
			
			<li><a href="http://javascript.ruanyifeng.com/#introduction">导论</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#grammar">基本语法</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#stdlib">标准库</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#oop">面向对象编程</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#dom">DOM</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#bom">浏览器对象</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#htmlapi">HTML网页的API</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#jquery">jQuery</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#tool">开发工具</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#advanced">高级语法</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#appendix">附录</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#library">草稿一：函数库</a></li>
			
			<li><a href="http://javascript.ruanyifeng.com/#nodejs">草稿二：Node.js</a></li>
			
		</ul>
	</li>
</ul>

<section>


<ul class="left">
<li class="divider"></li>
<li class="has-dropdown"><a class="active" href="http://javascript.ruanyifeng.com/oop/basic.html#"> 面向对象编程 </a><ul class="dropdown">



















<li class="active"><a href="http://javascript.ruanyifeng.com/oop/basic.html#">面向对象编程概述</a></li>











































<li><a href="http://javascript.ruanyifeng.com/oop/encapsulation.html">封装</a></li>







































<li><a href="http://javascript.ruanyifeng.com/oop/inheritance.html">继承</a></li>



















<li><a href="http://javascript.ruanyifeng.com/oop/module.html">JavaScript模块化编程</a></li>























































































</ul></li>
<li class="divider"></li>
<li class="has-dropdown nav-3"><a href="http://javascript.ruanyifeng.com/oop/basic.html#"> 面向对象编程概述</a><ul class="dropdown">
<li class="toc-h2"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc0">简介</a></li><li class="toc-h2"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc5">this关键字</a></li><li class="toc-h2"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc9">固定this的方法</a></li><li class="toc-h2"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc13">参考链接</a></li></ul></li>
</ul>


<ul class="right">
	<li class="divider"></li>
	<li>
		<a href="https://github.com/ruanyf/jstutorial" target="_blank">GitHub <i class="foundicon-edit"></i></a>
	</li>
	<li class="divider"></li>
	<li>
		<a href="http://javascript.ruanyifeng.com/oop/basic.html#">TOP <i class="foundicon-up-arrow"></i></a>
	</li>
</ul>

</section>

</nav>  
</div>
</header>


<article class="bookPage">

  <div class="row">
    <div class="twelve columns">

<h1> 面向对象编程概述 </h1>

<aside class="right"><p>来自<a href="http://javascript.ruanyifeng.com/">《JavaScript 标准参考教程（alpha）》</a>，by 阮一峰</p></aside>

<h2>目录</h2><div id="toc" class="panel callout radius"><ul><li class="toc-h2"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc0">简介</a></li><li class="toc-h3"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc1">对象和面向对象编程</a></li><li class="toc-h3"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc2">构造函数</a></li><li class="toc-h3"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc3">new命令</a></li><li class="toc-h3"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc4">instanceof运算符</a></li><li class="toc-h2"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc5">this关键字</a></li><li class="toc-h3"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc6">涵义</a></li><li class="toc-h3"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc7">使用场合</a></li><li class="toc-h3"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc8">使用注意点</a></li><li class="toc-h2"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc9">固定this的方法</a></li><li class="toc-h3"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc10">call方法</a></li><li class="toc-h3"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc11">apply方法</a></li><li class="toc-h3"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc12">bind方法</a></li><li class="toc-h2 toc-active"><a href="http://javascript.ruanyifeng.com/oop/basic.html#toc13">参考链接</a></li></ul></div>


<span id="toc0"></span><div class="chapter"><h2 id="简介">简介</h2></div>

<span id="toc1"></span><h3 id="对象和面向对象编程">对象和面向对象编程</h3>

<p>“面向对象编程”（Object Oriented Programming，缩写为OOP）是目前主流的编程范式。它的核心思想是将真实世界中各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>

<p>传统的计算机程序由一系列函数或一系列指令组成，而面向对象编程的程序由一系列对象组成。每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。因此，面向对象编程具有灵活性、代码的可重用性、模块性等特点，容易维护和开发，非常适合多人合作的大型软件项目。</p>

<p>那么，“对象”（object）到底是什么？</p>

<p>我们从两个层次来理解。</p>

<p><strong>（1）“对象”是单个实物的抽象。</strong></p>

<p>一本书、一辆汽车、一个人都可以是“对象”，一个数据库、一张网页、一个与远程服务器的连接也可以是“对象”。当实物被抽象成“对象”，实物之间的关系就变成了“对象”之间的关系，从而就可以模拟现实情况，针对“对象”进行编程。</p>

<p><strong>（2）“对象”是一个容器，封装了“属性”（property）和“方法”（method）。</strong></p>

<p>所谓“属性”，就是对象的状态；所谓“方法”，就是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，“属性”记录具体是那一种动物，“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p>

<p>虽然不同于传统的面向对象编程语言，但是JavaScript具有很强的面向对象编程能力。本章介绍JavaScript如何进行“面向对象编程”。</p>

<span id="toc2"></span><h3 id="构造函数">构造函数</h3>

<p>“面向对象编程”的第一步，就是要生成对象。</p>

<p>前面说过，“对象”是单个实物的抽象。所以，通常需要一个模板，表示某一类实物的共同特征，然后“对象”根据这个模板生成。</p>

<p>典型的面向对象编程语言（比如C++和Java），存在“类”（class）这样一个概念。所谓“类”就是对象的模板，对象就是“类”的实例。JavaScript语言没有“类”，而改用构造函数（constructor）作为对象的模板。</p>

<p>所谓“构造函数”，就是专门用来生成“对象”的函数。它提供模板，作为对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。</p>

<p>构造函数是一个正常的函数，但是它的特征和用法与普通函数不一样。下面就是一个构造函数：</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Vehicle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>上面代码中，Vehicle就是构造函数，它提供模板，用来生成车辆对象。</p>

<p>构造函数的最大特点就是，函数体内部使用了this关键字，代表了所要生成的对象实例。生成对象的时候，必需用new命令，调用Vehicle函数。</p>

<span id="toc3"></span><h3 id="new命令">new命令</h3>

<p>new命令的作用，就是执行构造函数，返回一个实例对象。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Vehicle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vehicle</span><span class="p">();</span>
<span class="nx">v</span><span class="p">.</span><span class="nx">price</span> <span class="c1">// 1000</span></code></pre></div>

<p>上面代码通过new命令，让构造函数Vehicle生成一个实例对象，保存在变量v中。这个新生成的实例对象，从构造函数Vehicle继承了price属性。在new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，它的值是1000。</p>

<p>new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vehicle</span><span class="p">();</span>
<span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vehicle</span><span class="p">;</span></code></pre></div>

<p>我们修改构造函数，使其可以带一个参数。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">Vehicle</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">price</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>这时使用new命令，就需要同时提供参数值。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vehicle</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span></code></pre></div>

<p>一个很自然的问题是，如果忘了使用new命令，直接调用构造函数会发生什么事？</p>

<p>这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于下面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。因此，应该避免出现不使用new命令、直接调用构造函数的情况。</p>

<p>为了保证构造函数必须与new命令一起使用，一个解决办法是，在构造函数内部使用严格模式，即第一行加上“use strict”。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Fubar</span> <span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">)</span> <span class="p">{</span>
  <span class="s2">"use strict"</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">Fubar</span><span class="p">()</span>
<span class="c1">// TypeError: Cannot set property '_foo' of undefined</span>
</code></pre></div>
<p>上面代码的Fubar为构造函数，use strict命令保证了该函数在严格模式下运行。由于在严格模式中，函数内部的this不能指向全局对象，默认等于undefined，导致不加new调用会报错（JavaScript不允许对undefined添加属性）。</p>

<p>另一个解决办法，是在构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Fubar</span> <span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Fubar</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nx">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">);</span>
  <span class="p">}</span> 

  <span class="k">this</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>上面代码中的构造函数，不管加不加new命令，都会得到同样的结果。</p>

<span id="toc4"></span><h3 id="instanceof运算符">instanceof运算符</h3>

<p>instanceof运算符用来确定一个对象是否为某个构造函数的实例。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">v</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vehicle</span><span class="p">();</span>

<span class="nx">v</span> <span class="k">instanceof</span> <span class="nx">Vehicle</span>
<span class="c1">// true</span></code></pre></div>

<p>instanceof运算符的左边放置对象，右边放置构造函数。在JavaScript之中，只要是对象，就有对应的构造函数。因此，instanceof运算符可以用来判断值的类型。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">instanceof</span> <span class="nb">Array</span> <span class="c1">// true</span>

<span class="p">({})</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="c1">// true</span></code></pre></div>

<p>上面代码表示数组和对象则分别是Array对象和Object对象的实例。最后那一行的空对象外面，之所以要加括号，是因为如果不加，JavaScript引擎会把一对大括号解释为一个代码块，而不是一个对象，从而导致这一行代码被解释为“{}; instanceof Object”，引擎就会报错。 </p>

<p>需要注意的是，由于原始类型的值不是对象，所以不能使用instanceof运算符判断类型。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="s2">""</span> <span class="k">instanceof</span> <span class="nb">String</span> <span class="c1">// false</span>

<span class="mi">1</span> <span class="k">instanceof</span> <span class="nb">Number</span> <span class="c1">// false</span></code></pre></div>

<p>上面代码中，字符串不是String对象的实例（因为字符串不是对象），数值1也不是Number对象的实例（因为数值1不是对象）。</p>

<p>如果存在继承关系，也就是某个对象可能是多个构造函数的实例，那么instanceof运算符对这些构造函数都返回true。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[];</span>

<span class="nx">a</span> <span class="k">instanceof</span> <span class="nb">Array</span> <span class="c1">// true</span>
<span class="nx">a</span> <span class="k">instanceof</span> <span class="nb">Object</span> <span class="c1">// true</span></code></pre></div>

<p>上面代码表示，a是一个数组，所以它是Array的实例；同时，a也是一个对象，所以它也是Object的实例。</p>

<p>利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">Fubar</span> <span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="k">instanceof</span> <span class="nx">Fubar</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_foo</span> <span class="o">=</span> <span class="nx">foo</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">_bar</span> <span class="o">=</span> <span class="nx">bar</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">return</span> <span class="k">new</span> <span class="nx">Fubar</span><span class="p">(</span><span class="nx">foo</span><span class="p">,</span> <span class="nx">bar</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>上面代码使用instanceof运算符，在函数体内部判断this关键字是否为构造函数Fubar的实例。如果不是，就表明忘了加new命令。</p>

<span id="toc5"></span><div class="chapter"><h2 id="this关键字">this关键字</h2></div>

<span id="toc6"></span><h3 id="涵义">涵义</h3>

<p>构造函数内部需要用到this关键字。那么，this关键字到底是什么意思呢？</p>

<p>简单说，this就是指当前函数的运行环境。由于JavaScript支持运行环境的动态切换，所以this的指向是动态的。</p>

<p>举例来说，有一个函数f，它同时充当a对象和b对象的方法。JavaScript允许函数f的运行环境动态切换，即一会属于a对象，一会属于b对象，这就要靠this关键字来办到。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">x</span><span class="p">);</span> <span class="p">};</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="s1">'a'</span><span class="p">};</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="nx">f</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span><span class="nx">x</span><span class="o">:</span><span class="s1">'b'</span><span class="p">};</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="nx">f</span><span class="p">;</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">m</span><span class="p">()</span> <span class="c1">// a</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">m</span><span class="p">()</span> <span class="c1">// b</span></code></pre></div>

<p>上面代码中，函数f可以打印出当前运行环境中x变量的值。当f属于a对象时，this指向a；当f属于b对象时，this指向b，因此打印出了不同的值。由于this的指向可变，所以达到了运行环境动态切换的目的。</p>

<p>从上面的例子可以看出，所谓“运行环境”其实就是对象。可以理解成，this指函数运行时所在的那个对象。如果一个函数在全局环境中运行，this就是指顶层对象（浏览器中为window对象）；如果一个函数作为某个对象的方法运行，this就是指那个对象。</p>

<span id="toc7"></span><h3 id="使用场合">使用场合</h3>

<p>this的使用可以分成以下几个场合。</p>

<p><strong>（1）全局环境</strong></p>

<p>在全局环境使用this，它指的就是顶层对象window。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span> <span class="c1">// true </span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span> <span class="c1">// true</span>
<span class="p">}</span></code></pre></div>

<p>上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this就是指全局对象window。</p>

<p><strong>（2）构造函数</strong></p>

<p>构造函数中的this，指的是实例对象。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">O</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">O</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>上面代码定义了一个构造函数O。由于this指向实例对象，所以在构造函数内部定义this.p，就相当于定义实例对象有一个p属性；然后m方法可以返回这个p属性。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">O</span><span class="p">(</span><span class="s2">"Hello World!"</span><span class="p">);</span>

<span class="nx">o</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// "Hello World!"</span>
<span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">()</span> <span class="c1">// "Hello World!"</span></code></pre></div>

<p><strong>（3）对象的方法</strong></p>

<p>当a对象的方法被赋予b对象，该方法就变成了普通函数，其中的this就从指向a对象变成了指向b对象。这就是this取决于运行时所在的对象的含义，所以要特别小心。如果将某个对象的方法赋值给另一个对象，会改变this的指向。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">o1</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">o1</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">m</span><span class="p">);};</span>

<span class="nx">o1</span><span class="p">.</span><span class="nx">f</span><span class="p">()</span> <span class="c1">// 1</span>

<span class="kd">var</span> <span class="nx">o2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">o2</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">o2</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="nx">o1</span><span class="p">.</span><span class="nx">f</span>

<span class="nx">o2</span><span class="p">.</span><span class="nx">f</span><span class="p">()</span> <span class="c1">// 2</span></code></pre></div>

<p>从上面代码可以看到，f是o1的方法，但是如果在o2上面调用这个方法，f方法中的this就会指向o2。这就说明JavaScript函数的运行环境完全是动态绑定的，可以在运行时切换。</p>

<p>如果不想改变this的指向，可以将o2.f改写成下面这样。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">o2</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span> <span class="nx">o1</span><span class="p">.</span><span class="nx">f</span><span class="p">()</span> <span class="p">};</span>

<span class="nx">o2</span><span class="p">.</span><span class="nx">f</span><span class="p">()</span> <span class="c1">// 1</span></code></pre></div>

<p>上面代码表示，由于f方法这时是在o1下面运行，所以this就指向o1。</p>

<p>有时，某个方法位于多层对象的内部，这时如果为了简化书写，把该方法赋值给一个变量，往往会得到意想不到的结果。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
        <span class="nx">b</span> <span class="o">:</span> <span class="p">{</span>
            <span class="nx">m</span> <span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">);</span>
            <span class="p">},</span>
            <span class="nx">p</span> <span class="o">:</span> <span class="s1">'Hello'</span>
        <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">hello</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">m</span><span class="p">;</span>
<span class="nx">hello</span><span class="p">()</span> <span class="c1">// undefined</span></code></pre></div>

<p>上面代码表示，m属于多层对象内部的一个方法。为求简写，将其赋值给hello变量，结果调用时，this指向了全局对象。为了避免这个问题，可以只将m所在的对象赋值给hello，这样调用时，this的指向就不会变。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">hello</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
<span class="nx">hello</span><span class="p">.</span><span class="nx">m</span><span class="p">()</span> <span class="c1">// Hello</span></code></pre></div>

<p><strong>（4）Node.js</strong></p>

<p>在Node.js中，this的指向又分成两种情况。全局环境中，this指向全局对象global；模块环境中，this指向module.exports。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// 全局环境</span>
<span class="k">this</span> <span class="o">===</span> <span class="nx">global</span> <span class="c1">// true</span>

<span class="c1">// 模块环境</span>
<span class="k">this</span> <span class="o">===</span> <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="c1">// true</span>
</code></pre></div>
<span id="toc8"></span><h3 id="使用注意点">使用注意点</h3>

<p><strong>（1）避免多层this</strong></p>

<p>由于this的指向是不确定的，所以切勿在函数中包含多层的this。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">f1</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> 
        <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="p">}();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nx">f1</span><span class="p">()</span>
<span class="c1">// Object</span>
<span class="c1">// Window</span></code></pre></div>

<p>上面代码包含两层this，结果运行后，第一层指向该对象，第二层指向全局对象。一个解决方法是在第二层改用一个指向外层this的变量。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">f1</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span> 
        <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">that</span><span class="p">);</span>
        <span class="p">}();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nx">f1</span><span class="p">()</span>
<span class="c1">// Object</span>
<span class="c1">// Object</span></code></pre></div>

<p>上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。</p>

<p><strong>（2）避免数组处理方法中的this</strong></p>

<p>数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">v</span><span class="o">:</span> <span class="s1">'hello'</span><span class="p">,</span>
    <span class="nx">p</span><span class="o">:</span> <span class="p">[</span> <span class="s1">'a1'</span><span class="p">,</span> <span class="s1">'a2'</span> <span class="p">],</span>
    <span class="nx">f</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">v</span><span class="o">+</span><span class="s1">' '</span><span class="o">+</span><span class="nx">item</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nx">f</span><span class="p">()</span>
<span class="c1">// undefined a1</span>
<span class="c1">// undefined a2</span></code></pre></div>

<p>上面代码中，foreach方法的参数函数中的this，其实是指向window对象，因此取不到o.v的值。</p>

<p>解决这个问题的一种方法，是使用中间变量。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">v</span><span class="o">:</span> <span class="s1">'hello'</span><span class="p">,</span>
    <span class="nx">p</span><span class="o">:</span> <span class="p">[</span> <span class="s1">'a1'</span><span class="p">,</span> <span class="s1">'a2'</span> <span class="p">],</span>
    <span class="nx">f</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">v</span><span class="o">+</span><span class="s1">' '</span><span class="o">+</span><span class="nx">item</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nx">f</span><span class="p">()</span>
<span class="c1">// hello a1</span>
<span class="c1">// hello a2</span></code></pre></div>

<p>另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">v</span><span class="o">:</span> <span class="s1">'hello'</span><span class="p">,</span>
    <span class="nx">p</span><span class="o">:</span> <span class="p">[</span> <span class="s1">'a1'</span><span class="p">,</span> <span class="s1">'a2'</span> <span class="p">],</span>
    <span class="nx">f</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">v</span><span class="o">+</span><span class="s1">' '</span><span class="o">+</span><span class="nx">item</span><span class="p">);</span>
        <span class="p">},</span> <span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nx">f</span><span class="p">()</span>
<span class="c1">// hello a1</span>
<span class="c1">// hello a2</span></code></pre></div>

<p><strong>（3）避免回调函数中的this</strong></p>

<p>回调函数中的this往往会改变指向，最好避免使用。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>

<span class="nx">o</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">o</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">o</span><span class="p">.</span><span class="nx">f</span><span class="p">()</span> <span class="c1">// true</span></code></pre></div>

<p>上面代码表示，如果调用o对象的f方法，其中的this就是指向o对象。</p>

<p>但是，如果将f方法指定给某个按钮的click事件，this的指向就变了。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s2">"#button"</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s2">"click"</span><span class="p">,</span> <span class="nx">o</span><span class="p">.</span><span class="nx">f</span><span class="p">);</span></code></pre></div>

<p>点击按钮以后，控制台会显示false。原因是此时this不再指向o对象，而是指向按钮的DOM对象，因为f方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p>

<p>为了解决这个问题，可以采用下面的一些方法对this进行绑定，也就是使得this固定指向某个对象，减少不确定性。</p>

<span id="toc9"></span><div class="chapter"><h2 id="固定this的方法">固定this的方法</h2></div>

<p>this的动态切换，固然为JavaScript创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，反正出现意想不到的情况。</p>

<p>JavaScript提供了call、apply、bind这三个方法，来固定this的指向。</p>

<span id="toc10"></span><h3 id="call方法">call方法</h3>

<p>函数的call方法，可以改变指定该函数内部this的指向，然后再调用该函数。它的使用格式如下。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">func</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">thisValue</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">,</span> <span class="p">...)</span></code></pre></div>

<p>call方法的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。如果this所要指向的那个对象，设定为null或undefined，则等同于指定全局对象。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">n</span> <span class="o">:</span> <span class="mi">456</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">call</span><span class="p">()</span> <span class="c1">// 123</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span> <span class="c1">// 123</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">undefined</span><span class="p">)</span> <span class="c1">// 123</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nb">window</span><span class="p">)</span> <span class="c1">// 123</span>
<span class="nx">a</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">o</span><span class="p">)</span> <span class="c1">// 456</span></code></pre></div>

<p>上面代码中，a函数中的this关键字，如果指向全局对象，返回结果为123。如果使用call方法，将this关键字指向o对象，返回结果为456。</p>

<span id="toc11"></span><h3 id="apply方法">apply方法</h3>

<p>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。它的使用格式如下。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">thisValue</span><span class="p">,</span> <span class="p">[</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">,</span> <span class="p">...])</span></code></pre></div>

<p>apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。</p>

<p>请看下面的例子。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">){</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">);</span> <span class="p">}</span>

<span class="nx">f</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1">// 2</span>
<span class="nx">f</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="c1">// 2</span></code></pre></div>

<p>上面的f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数。</p>

<p>利用这一点，可以做一些有趣的应用。</p>

<p><strong>（1）找出数组最大元素</strong></p>

<p>JavaScript不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">9</span><span class="p">];</span>

<span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="c1">// 15</span></code></pre></div>

<p><strong>（2）将数组的空元素变为undefined</strong></p>

<p>通过apply方法，利用Array构造函数将数组的空元素变成undefined。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Array</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">,,</span><span class="s2">"b"</span><span class="p">])</span>
<span class="c1">// [ 'a', undefined, 'b' ]</span></code></pre></div>

<p>空元素与undefined的差别在于，数组的foreach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"a"</span><span class="p">,,</span><span class="s2">"b"</span><span class="p">];</span>

<span class="kd">function</span> <span class="nx">print</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">print</span><span class="p">)</span>
<span class="c1">// a</span>
<span class="c1">// b</span>

<span class="nb">Array</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="nx">a</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">print</span><span class="p">)</span>
<span class="c1">// a</span>
<span class="c1">// undefined</span>
<span class="c1">// b</span></code></pre></div>

<p><strong>（3）转换类似数组的对象</strong></p>

<p>另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">apply</span><span class="p">({</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span><span class="nx">length</span><span class="o">:</span><span class="mi">1</span><span class="p">})</span>
<span class="c1">// [1]</span>

<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">apply</span><span class="p">({</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">})</span>
<span class="c1">// []</span>

<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">apply</span><span class="p">({</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span><span class="nx">length</span><span class="o">:</span><span class="mi">2</span><span class="p">})</span>
<span class="c1">// [1, undefined]</span>

<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">apply</span><span class="p">({</span><span class="nx">length</span><span class="o">:</span><span class="mi">1</span><span class="p">})</span>
<span class="c1">// [undefined]</span></code></pre></div>

<p>上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。</p>

<p><strong>（4）绑定回调函数的对象</strong></p>

<p>上一节按钮点击事件的例子，可以改写成</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>

<span class="nx">o</span><span class="p">.</span><span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">o</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="nx">o</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
    <span class="c1">// 或者 o.f.call(o);</span>
<span class="p">};</span>

<span class="nx">$</span><span class="p">(</span><span class="s2">"#button"</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s2">"click"</span><span class="p">,</span> <span class="nx">f</span><span class="p">);</span></code></pre></div>

<p>点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的bind方法。</p>

<span id="toc12"></span><h3 id="bind方法">bind方法</h3>

<p>bind方法就是单纯地将函数体内的this绑定到某个对象，然后返回一个新函数。它的使用格式如下。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">func</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">thisValue</span><span class="p">,</span> <span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">,...)</span></code></pre></div>

<p>它比call方法和apply方法更进一步的是，除了绑定this以外，还可以绑定原函数的参数。</p>

<p>请看下面的例子。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">o1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">o1</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
<span class="nx">o1</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">p</span><span class="p">);</span>
<span class="p">};</span>

<span class="nx">o1</span><span class="p">.</span><span class="nx">m</span><span class="p">()</span> <span class="c1">// 123 </span>

<span class="kd">var</span> <span class="nx">o2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">o2</span><span class="p">.</span><span class="nx">p</span> <span class="o">=</span> <span class="mi">456</span><span class="p">;</span>
<span class="nx">o2</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="nx">o1</span><span class="p">.</span><span class="nx">m</span><span class="p">;</span>

<span class="nx">o2</span><span class="p">.</span><span class="nx">m</span><span class="p">()</span> <span class="c1">// 456</span>

<span class="nx">o2</span><span class="p">.</span><span class="nx">m</span> <span class="o">=</span> <span class="nx">o1</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">o1</span><span class="p">);</span>
<span class="nx">o2</span><span class="p">.</span><span class="nx">m</span><span class="p">()</span> <span class="c1">// 123</span></code></pre></div>

<p>上面代码使用bind方法将o1.m方法绑定到o1以后，在o2对象上调用o1.m的时候，o1.m函数体内部的this.p就不再到o2对象去寻找p属性的值了。</p>

<p>如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向全局对象（在浏览器中为window）。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">;</span> <span class="p">}</span>

<span class="kd">var</span> <span class="nx">plus5</span> <span class="o">=</span> <span class="nx">add</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>

<span class="nx">plus5</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// 15</span></code></pre></div>

<p>上面代码除了将add函数的运行环境绑定为全局对象，还将add函数的第一个参数绑定为5，然后返回一个新函数。以后，每次运行这个新函数，就只需要提供另一个参数就够了。</p>

<p>bind方法有一些使用注意点。</p>

<p><strong>（1）每一次返回一个新函数</strong></p>

<p>bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'click'</span><span class="p">,</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">o</span><span class="p">));</span></code></pre></div>

<p>上面代码表示，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">element</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="s1">'click'</span><span class="p">,</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">o</span><span class="p">));</span></code></pre></div>

<p>正确的方法是写成下面这样：</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">listener</span> <span class="o">=</span> <span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'click'</span><span class="p">,</span> <span class="nx">listener</span><span class="p">);</span>
<span class="c1">//  ...</span>
<span class="nx">element</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="s1">'click'</span><span class="p">,</span> <span class="nx">listener</span><span class="p">);</span></code></pre></div>

<p><strong>（2）bind方法的自定义代码</strong></p>

<p>对于那些不支持bind方法的老式浏览器，可以自行定义bind方法。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="s1">'bind'</span> <span class="k">in</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)){</span>
    <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="kd">var</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="kd">var</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">context</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p><strong>（3）jQuery的proxy方法</strong></p>

<p>除了用bind方法绑定函数运行时所在的对象，还可以使用jQuery的$.proxy方法，它与bind方法的作用基本相同。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s2">"#button"</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="s2">"click"</span><span class="p">,</span> <span class="nx">$</span><span class="p">.</span><span class="nx">proxy</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">f</span><span class="p">,</span> <span class="nx">o</span><span class="p">));</span></code></pre></div>

<p>上面代码表示，$.proxy方法将o.f方法绑定到o对象。</p>

<p><strong>（4）结合call方法使用</strong></p>

<p>利用bind方法，可以改写一些JavaScript原生方法的使用形式，以数组的slice方法为例。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
<span class="c1">// [1]</span>

<span class="c1">// 等同于</span>

<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">// [1]</span></code></pre></div>

<p>上面的代码中，数组的slice方法从[1, 2, 3]里面，按照指定位置和长度切分出另一个数组。这样做的本质是在[1, 2, 3]上面调用Array.prototype.slice方法，因此可以用call方法表达这个过程，得到同样的结果。</p>

<p>call方法实质上是调用Function.prototype.call方法，因此上面的表达式可以用bind方法改写。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">slice</span> <span class="o">=</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">);</span>

<span class="nx">slice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// [1]</span></code></pre></div>

<p>可以看到，利用bind方法，将[1, 2, 3].slice(0, 1)变成了slice([1, 2, 3], 0, 1)的形式。这种形式的改变还可以用于其他数组方法。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">push</span> <span class="o">=</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">push</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">pop</span> <span class="o">=</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">pop</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="p">,</span><span class="mi">2</span> <span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="nx">push</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nx">a</span> <span class="c1">// [1, 2, 3, 4]</span>

<span class="nx">pop</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="nx">a</span> <span class="c1">// [1, 2, 3]</span></code></pre></div>

<p>如果再进一步，将Function.prototype.call方法绑定到Function.prototype.bind对象，就意味着bind的调用形式也可以被改写。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">v</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">v</span><span class="o">:</span> <span class="mi">123</span> <span class="p">};</span>

<span class="kd">var</span> <span class="nx">bind</span> <span class="o">=</span> <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">call</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">bind</span><span class="p">);</span>

<span class="nx">bind</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span><span class="nx">o</span><span class="p">)()</span> <span class="c1">// 123</span></code></pre></div>

<p>上面代码表示，将Function.prototype.call方法绑定Function.prototype.bind以后，bind方法的使用形式从f.bind(o)，变成了bind(f, o)。</p>

<span id="toc13"></span><div class="chapter"><h2 id="参考链接" class="reference">参考链接</h2></div>

<ul class="reference-list">
<li>Jonathan Creamer, <a href="http://tech.pro/tutorial/1192/avoiding-the-this-problem-in-javascript">Avoiding the "this" problem in JavaScript</a></li>
<li>Erik Kronberg, <a href="https://variadic.me/posts/2013-10-22-bind-call-and-apply-in-javascript.html">Bind, Call and Apply in JavaScript</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2014/05/this.html">JavaScript’s this: how it works, where it can trip you up</a></li>
</ul>


</div></div></article>

<div class="row">
    <div class="twelve columns">

<sectioni id="feature">

<h2>功能链接</h2>

<ul>

	<li><a href="https://github.com/ruanyf/jstutorial/issues">论坛</a></li>
	<li><a href="https://raw.github.com/ruanyf/jstutorial/gh-pages/oop/basic.md">Markdown源码</a></li>
	<li><a href="https://github.com/ruanyf/jstutorial/commits/gh-pages/oop/basic.md">修订历史</a></li>

</ul>

<h2>留言</h2>

<div id="disqus_thread"><iframe id="dsq-2" data-disqus-uid="2" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./basic_files/saved_resource.htm" style="width: 100% !important; border: none !important; overflow: hidden !important; height: 4713px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'jstutorial'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the &lt;a href="http://disqus.com/?ref_noscript"&gt;comments powered by Disqus.&lt;/a&gt;</noscript>
    



</sectioni></div>
</div>

<footer>
<div class="row">
<div class="twelve columns">
	<p><a href="http://javascript.ruanyifeng.com/introduction/license.html">版权声明</a> | last modified on 2014-02-04 </p>
</div>
</div>
</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43771063-1', 'ruanyifeng.com');
  ga('send', 'pageview');
</script>




</body></html>